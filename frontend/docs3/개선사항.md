# FSD 아키텍처 개선 사항

현재 프로젝트는 FSD(Feature-Sliced Design) 아키텍처를 기반으로 구현되어 있으며, 특히 Product 도메인에서 이 아키텍처가 잘 적용되어 있습니다. 하지만 더 엄격하게 FSD 원칙을 따르고 코드베이스의 유지보수성과 확장성을 높이기 위해 다음과 같은 개선 사항을 제안합니다.

## 1. 레이어 간 의존성 강화

### 현재 상황
- 일부 컴포넌트에서 레이어 간 의존성 규칙이 완벽하게 지켜지지 않는 경우가 있습니다.
- 예를 들어, `ProductCard.vue`에서 `features/cart`의 기능을 직접 사용하고 있습니다.

### 개선 방안
- 엔티티 레이어의 UI 컴포넌트는 기능 레이어에 의존하지 않아야 합니다.
- `ProductCard.vue`에서 장바구니 추가 기능을 이벤트로 분리하고, 상위 컴포넌트에서 처리하도록 변경합니다.
- 예시 코드:
```vue
<!-- 변경 전 -->
<button @click="addToCart">장바구니에 담기</button>

<!-- 변경 후 -->
<button @click="$emit('add-to-cart', product)">장바구니에 담기</button>
```

## 2. 공개 API 명확화

### 현재 상황
- 일부 슬라이스에서 내부 구현 세부 사항이 외부에 노출되는 경우가 있습니다.
- `index.ts` 파일을 통한 공개 API가 일관되게 적용되지 않는 경우가 있습니다.

### 개선 방안
- 모든 슬라이스에서 `index.ts` 파일을 통해 명확한 공개 API를 제공합니다.
- 내부 구현 세부 사항은 외부에 노출하지 않습니다.
- 예시:
```typescript
// entities/product/index.ts
// 공개 API만 명확하게 export
export type { Product, ProductStock } from './model/types';
export { ProductCategory, ProductStatus } from './model/constants';
export { useProductStore } from './model/productStore';
export { default as ProductCard } from './ui/ProductCard.vue';

// 내부 구현 세부 사항은 export하지 않음
// export { someInternalFunction } from './model/helpers'; // 이런 방식은 지양
```

## 3. 슬라이스 독립성 강화

### 현재 상황
- 일부 슬라이스가 다른 슬라이스에 직접 의존하는 경우가 있습니다.
- 같은 레이어 내에서 슬라이스 간 의존성이 발생하는 경우가 있습니다.

### 개선 방안
- 슬라이스 간 의존성을 최소화하고, 필요한 경우 공유 레이어(shared)를 통해 공통 기능을 제공합니다.
- 슬라이스 간 통신이 필요한 경우, 이벤트 버스나 상태 관리 도구를 활용합니다.
- 예시:
```typescript
// 변경 전: 직접 의존
import { someFunction } from '@entities/anotherEntity';

// 변경 후: shared 레이어를 통한 공유
import { someSharedFunction } from '@shared/lib/helpers';
```

## 4. 모델 계층 강화

### 현재 상황
- 일부 비즈니스 로직이 UI 컴포넌트나 스토어에 직접 구현되어 있습니다.
- 도메인 모델과 비즈니스 로직이 명확하게 분리되지 않은 경우가 있습니다.

### 개선 방안
- 비즈니스 로직을 모델 계층으로 이동하여 UI와 분리합니다.
- 도메인 모델에 메서드를 추가하여 관련 로직을 캡슐화합니다.
- 예시:
```typescript
// 변경 전: UI 컴포넌트에 비즈니스 로직 구현
const calculateDiscountRate = (originalPrice, currentPrice) => {
  return Math.round(((originalPrice - currentPrice) / originalPrice) * 100);
};

// 변경 후: 모델 계층에 비즈니스 로직 구현
// entities/product/model/product.ts
export class Product {
  // ... 속성들
  
  calculateDiscountRate(): number {
    return Math.round(((this.originalPrice - this.price) / this.originalPrice) * 100);
  }
}
```

## 5. 테스트 커버리지 확대

### 현재 상황
- 테스트 커버리지가 충분하지 않은 영역이 있습니다.
- 특히 엔티티와 기능 레이어의 비즈니스 로직에 대한 단위 테스트가 부족합니다.

### 개선 방안
- 각 레이어와 슬라이스에 맞는 테스트 전략을 적용합니다.
- 엔티티와 기능 레이어의 비즈니스 로직에 대한 단위 테스트를 추가합니다.
- 위젯과 페이지 레이어에 대한 통합 테스트를 추가합니다.
- 예시:
```typescript
// entities/product/model/product.test.ts
describe('Product', () => {
  it('should calculate discount rate correctly', () => {
    const product = new Product({
      originalPrice: 100,
      price: 80,
      // ... 다른 필수 속성들
    });
    
    expect(product.calculateDiscountRate()).toBe(20);
  });
});
```

## 6. 타입 안전성 강화

### 현재 상황
- 일부 코드에서 타입 안전성이 충분히 보장되지 않는 경우가 있습니다.
- `any` 타입이나 타입 단언(type assertion)이 과도하게 사용되는 경우가 있습니다.

### 개선 방안
- `any` 타입 사용을 최소화하고, 구체적인 타입을 정의합니다.
- 타입 가드와 제네릭을 활용하여 타입 안전성을 높입니다.
- 예시:
```typescript
// 변경 전: any 타입 사용
function processData(data: any) {
  return data.someProperty;
}

// 변경 후: 구체적인 타입 정의
interface DataType {
  someProperty: string;
}

function processData(data: DataType) {
  return data.someProperty;
}
```

## 7. 에러 처리 표준화

### 현재 상황
- 에러 처리 방식이 일관되지 않고, 일부 에러가 적절히 처리되지 않는 경우가 있습니다.
- 사용자에게 에러 메시지가 명확하게 전달되지 않는 경우가 있습니다.

### 개선 방안
- 에러 처리를 위한 표준 패턴을 정의하고 일관되게 적용합니다.
- 사용자 친화적인 에러 메시지를 제공합니다.
- 에러 로깅 및 모니터링 시스템을 구축합니다.
- 예시:
```typescript
// shared/api/error-handler.ts
export class ApiError extends Error {
  constructor(public code: string, message: string, public data?: any) {
    super(message);
    this.name = 'ApiError';
  }
}

export function handleApiError(error: unknown): string {
  if (error instanceof ApiError) {
    // 사용자 친화적인 에러 메시지 반환
    return getErrorMessage(error.code);
  }
  
  // 기타 에러 처리
  console.error('Unexpected error:', error);
  return '알 수 없는 오류가 발생했습니다.';
}
```

## 8. 성능 최적화

### 현재 상황
- 일부 컴포넌트에서 불필요한 리렌더링이 발생하는 경우가 있습니다.
- 대용량 데이터 처리 시 성능 이슈가 발생할 수 있습니다.

### 개선 방안
- 메모이제이션(computed, watch)을 활용하여 불필요한 리렌더링을 방지합니다.
- 가상 스크롤(virtual scrolling)을 적용하여 대용량 목록의 성능을 개선합니다.
- 코드 스플리팅과 지연 로딩을 활용하여 초기 로딩 시간을 단축합니다.
- 예시:
```vue
<!-- 변경 전: 일반 목록 -->
<template>
  <div>
    <div v-for="product in products" :key="product.id">
      <ProductCard :product="product" />
    </div>
  </div>
</template>

<!-- 변경 후: 가상 스크롤 적용 -->
<template>
  <RecycleScroller
    class="scroller"
    :items="products"
    :item-size="200"
    key-field="id"
  >
    <template #default="{ item }">
      <ProductCard :product="item" />
    </template>
  </RecycleScroller>
</template>
```

## 9. 국제화(i18n) 지원 강화

### 현재 상황
- 일부 텍스트가 하드코딩되어 있어 다국어 지원이 어려운 경우가 있습니다.
- 국제화 관련 기능이 일관되게 적용되지 않는 경우가 있습니다.

### 개선 방안
- 모든 텍스트를 국제화 라이브러리를 통해 관리합니다.
- 날짜, 시간, 통화 등의 형식을 지역에 맞게 표시합니다.
- 예시:
```vue
<!-- 변경 전: 하드코딩된 텍스트 -->
<button>장바구니에 담기</button>

<!-- 변경 후: i18n 적용 -->
<button>{{ $t('product.addToCart') }}</button>
```

## 10. 접근성(a11y) 개선

### 현재 상황
- 일부 UI 컴포넌트가 접근성 표준을 충족하지 못하는 경우가 있습니다.
- 키보드 네비게이션, 스크린 리더 지원 등이 부족한 경우가 있습니다.

### 개선 방안
- 모든 UI 컴포넌트에 적절한 ARIA 속성을 추가합니다.
- 키보드 네비게이션을 지원합니다.
- 색상 대비를 개선하여 가독성을 높입니다.
- 예시:
```vue
<!-- 변경 전: 접근성이 부족한 버튼 -->
<div class="button" @click="addToCart">장바구니에 담기</div>

<!-- 변경 후: 접근성이 개선된 버튼 -->
<button 
  @click="addToCart"
  aria-label="장바구니에 담기"
  :disabled="!product.inStock"
>
  장바구니에 담기
</button>
```

## 결론

위의 개선 사항들을 적용하면 FSD 아키텍처의 원칙을 더 엄격하게 따르고, 코드베이스의 유지보수성과 확장성을 높일 수 있습니다. 특히 레이어 간 의존성 강화, 공개 API 명확화, 슬라이스 독립성 강화는 FSD 아키텍처의 핵심 원칙을 더 잘 구현하는 데 도움이 될 것입니다.

이러한 개선 사항들은 점진적으로 적용하는 것이 좋으며, 각 변경 사항에 대한 테스트를 통해 기존 기능이 정상적으로 작동하는지 확인해야 합니다.